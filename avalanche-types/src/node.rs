use std::{
    fs,
    io::{self, Error, ErrorKind},
    path::Path,
    string::String,
};

use log::info;
use openssl::x509::X509;

use crate::key;

/// Defines the node type.
/// MUST BE either "anchor" or "non-anchor"
#[derive(Eq, PartialEq, Clone)]
pub enum Kind {
    Anchor,
    NonAnchor,
}

impl Kind {
    pub fn as_str(&self) -> &'static str {
        match self {
            Kind::Anchor => "anchor",
            Kind::NonAnchor => "non-anchor",
        }
    }
    pub fn from_str(&self, s: &str) -> io::Result<Self> {
        match s {
            "anchor" => Ok(Kind::Anchor),
            "non-anchor" => Ok(Kind::NonAnchor),
            "non_anchor" => Ok(Kind::NonAnchor),
            _ => Err(Error::new(
                ErrorKind::Other,
                format!("unknown node type '{}'", s),
            )),
        }
    }
}

/// Loads a node ID from the PEM-encoded X509 certificate.
/// ref. https://pkg.go.dev/github.com/ava-labs/avalanchego/node#Node.Initialize
pub fn load_id(cert_path: &str) -> io::Result<String> {
    info!("loading node ID from certificate {}", cert_path);
    if !Path::new(cert_path).exists() {
        return Err(Error::new(
            ErrorKind::NotFound,
            format!("cert path {} does not exists", cert_path),
        ));
    }

    let pub_key_contents = fs::read(cert_path).unwrap();
    let pub_key = X509::from_pem(&pub_key_contents.to_vec()).unwrap();

    // ref. "tls.Certificate.Leaf.Raw" in Go
    // ref. "tls.X509KeyPair"
    // ref. "x509.ParseCertificate/parseCertificate"
    // ref. "x509.Certificate.Leaf"
    let pub_key_der = pub_key.to_der().unwrap();

    // "ids.ToShortID(hashing.PubkeyBytesToAddress(StakingTLSCert.Leaf.Raw))"
    // ref. https://pkg.go.dev/github.com/ava-labs/avalanchego/node#Node.Initialize
    encode_id(&pub_key_der.to_vec())
}

/// Encodes the cert raw bytes to a node ID.
/// It applies "sha256" and "ripemd160" on "Certificate.Leaf.Raw".
/// ref. https://pkg.go.dev/github.com/ava-labs/avalanchego/utils/hashing#PubkeyBytesToAddress
/// ref. https://pkg.go.dev/github.com/ava-labs/avalanchego/ids#ToShortID
fn encode_id(cert_raw: &[u8]) -> io::Result<String> {
    let short_address = key::bytes_to_short_address(cert_raw)?;

    // ref. https://pkg.go.dev/github.com/ava-labs/avalanchego/ids#ShortID.PrefixedString
    // ref. "PrefixedString(constants.NodeIDPrefix)"
    let mut node_id = String::from("NodeID-");
    node_id.push_str(&short_address);
    Ok(node_id)
}

/// RUST_LOG=debug cargo test --package avalanche-types --lib -- node::test_id --exact --show-output
#[test]
fn test_id() {
    let _ = env_logger::builder().is_test(true).try_init();

    // copied from "avalanchego/staking/local/staking1.key,crt"
    // verified by "avalanchego-compatibility/node-id" for compatibility with Go
    let expected = "NodeID-7Xhw2mDxuDS44j42TCB6U5579esbSt3Lg";
    let node_id = load_id("./artifacts/staker1.insecure.crt").unwrap();
    assert_eq!(node_id, expected);

    let expected = "NodeID-MFrZFVCXPv5iCn6M9K6XduxGTYp891xXZ";
    let node_id = load_id("./artifacts/staker2.insecure.crt").unwrap();
    assert_eq!(node_id, expected);

    let expected = "NodeID-NFBbbJ4qCmNaCzeW7sxErhvWqvEQMnYcN";
    let node_id = load_id("./artifacts/staker3.insecure.crt").unwrap();
    assert_eq!(node_id, expected);

    let expected = "NodeID-GWPcbFJZFfZreETSoWjPimr846mXEKCtu";
    let node_id = load_id("./artifacts/staker4.insecure.crt").unwrap();
    assert_eq!(node_id, expected);

    let expected = "NodeID-P7oB2McjBGgW2NXXWVYjV8JEDFoW9xDE5";
    let node_id = load_id("./artifacts/staker5.insecure.crt").unwrap();
    assert_eq!(node_id, expected);

    // generated by "examples/cert.rs"
    // verified by "avalanchego-compatibility/local-node-id" for compatibility with Go
    //
    // e.g.,
    // cargo run --example cert \
    // -- ./artifacts/test.insecure.key \
    // ./artifacts/test.insecure.crt
    let expected = "NodeID-29HTAG5cfN2fw79A67Jd5zY9drcT51EBG";
    let node_id = load_id("./artifacts/test.insecure.crt").unwrap();
    assert_eq!(node_id, expected);
}
